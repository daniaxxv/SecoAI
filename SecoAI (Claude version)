import os
import json
import random
from typing import List, Dict, Any
from datetime import datetime, timedelta

from openai import OpenAI

class GrokClusteringAgent:
    """Агент кластеризації на базі Grok від xAI"""
    
    def __init__(self, api_key: str = None):
        """
        Ініціалізація агента для кластеризації користувачів
        
        Args:
            api_key: API ключ xAI (якщо не передано, береться з environ)
        """
        self.api_key = api_key or os.getenv('XAI_API_KEY')
        if not self.api_key:
            raise ValueError("Потрібен API ключ xAI")
        
        # Ініціалізація клієнта для Grok API
        self.client = OpenAI(
            api_key=self.api_key,
            base_url="https://api.x.ai/v1"
        )
        
        # ВИПРАВЛЕНО: Англійський системний промпт
        self.system_prompt = """You are an autonomous AI agent that integrates into various e-commerce systems. You are responsible for processing user data.
Your goal is to cluster similar users into groups to show the same content and reduce energy costs for data processing.
Work scheme: you receive input data about each user available in the service you will be integrated into. This includes behavioral, general, and demographic data of each user on the platform. You analyze each user's data, specifically: check age, gender, location, region, purchase history, user cart (if available), activity in the program, religion, interests (any available), and other available data. Based on these parameters, you look for similar users.
Users who are more than 80% similar to each other, you group into one cluster (the number of clusters and the number of users in clusters is unlimited), users assigned to one cluster are shown common content. Users who do not have similar users need to be processed personally. You must broadcast all your actions in real-time to the dashboard to which you will be connected. Return the result in JSON format."""

    def cluster_users(self, users_data: List[Dict[str, Any]]) -> Dict[str, Any]:
        """
        Кластеризація користувачів за допомогою Grok
        
        Args:
            users_data: Список словників з даними користувачів
            
        Returns:
            Словник з результатами кластеризації у форматі JSON
        """
        try:
            # ВИПРАВЛЕНО: Англійський промпт для користувача
            users_json = json.dumps(users_data, ensure_ascii=False, indent=2)
            
            user_message = f"""
Analyze the following users and group them into clusters:

{users_json}

Return the result in JSON format with the following structure:
{{
    "clusters": [
        {{
            "cluster_id": 1,
            "user_ids": [list of user IDs],
            "similarity_score": percentage of similarity,
            "common_traits": ["common characteristics"],
            "recommended_content": "type of content to show"
        }}
    ],
    "individual_users": [
        {{
            "user_id": ID,
            "reason": "reason for individual processing"
        }}
    ],
    "processing_log": [
        "step 1: ...",
        "step 2: ..."
    ]
}}
"""

            # Виклик Grok API
            response = self.client.chat.completions.create(
                model="grok-beta",
                messages=[
                    {"role": "system", "content": self.system_prompt},
                    {"role": "user", "content": user_message}
                ],
                temperature=0.3,
                max_tokens=4000,
                response_format={"type": "json_object"}
            )
            
            # Витягуємо результат
            result = json.loads(response.choices[0].message.content)
            
            return {
                "status": "success",
                "model": "Grok (xAI)",
                "data": result,
                "tokens_used": {
                    "prompt": response.usage.prompt_tokens,
                    "completion": response.usage.completion_tokens,
                    "total": response.usage.total_tokens
                }
            }
            
        except json.JSONDecodeError as e:
            return {
                "status": "error",
                "model": "Grok (xAI)",
                "error": f"JSON parsing error: {str(e)}",
                "raw_response": response.choices[0].message.content if 'response' in locals() else None,
                "data": None
            }
        except Exception as e:
            import traceback
            return {
                "status": "error",
                "model": "Grok (xAI)",
                "error": str(e),
                "error_type": type(e).__name__,
                "traceback": traceback.format_exc(),
                "data": None
            }

    def process_in_realtime(self, users_data: List[Dict[str, Any]], 
                           dashboard_callback=None) -> Dict[str, Any]:
        """
        Обробка з реал-тайм трансляцією на дашборд
        
        Args:
            users_data: Дані користувачів
            dashboard_callback: Функція для відправки оновлень на дашборд
            
        Returns:
            Результат кластеризації
        """
        if dashboard_callback:
            dashboard_callback({
                "status": "processing", 
                "message": "Grok started data processing..."
            })
        
        result = self.cluster_users(users_data)
        
        if dashboard_callback:
            dashboard_callback({
                "status": "completed" if result["status"] == "success" else "failed",
                "message": "Grok completed processing" if result["status"] == "success" else "Processing error",
                "result": result
            })
        
        return result


# ============== ГЕНЕРАТОР ФЕЙКОВИХ ДАНИХ ==============

class FakeDataGenerator:
    """Генератор фейкових даних для тестування агента"""
    
    def __init__(self):
        self.cities = [
            ("Kyiv", "Kyiv Oblast"),
            ("Lviv", "Lviv Oblast"),
            ("Kharkiv", "Kharkiv Oblast"),
            ("Odesa", "Odesa Oblast"),
            ("Dnipro", "Dnipropetrovsk Oblast"),
            ("Zaporizhzhia", "Zaporizhzhia Oblast"),
            ("Vinnytsia", "Vinnytsia Oblast"),
            ("Ivano-Frankivsk", "Ivano-Frankivsk Oblast")
        ]
        
        self.genders = ["male", "female"]
        
        self.religions = ["christianity", "islam", "judaism", "atheism", "other", None]
        
        self.product_categories = {
            "fashion": ["clothing", "footwear", "accessories", "bags", "sunglasses", "belts", "scarves", "gloves", "hats", "umbrellas"],
            "beauty": ["cosmetics", "perfumes", "skincare", "haircare", "manicure", "pedicure", "SPA", "massage"],
            "tech": ["electronics", "gadgets", "computers", "phones", "headphones", "tablets", "smartwatches", "speakers", "cameras", "drones"],
            "home": ["furniture", "decor", "dishes", "textiles", "lighting", "carpets", "pillows", "paintings", "mirrors", "candles"],
            "books": ["books", "magazines", "comics", "audiobooks", "e-books", "encyclopedias", "dictionaries", "educational"],
            "sports": ["sportswear", "sports equipment", "fitness accessories", "bicycles", "roller skates", "skateboards", "trainers", "balls"],
            "kids": ["toys", "kids clothing", "kids books", "board games", "construction sets", "dolls", "cars", "educational games"],
            "food": ["groceries", "delicacies", "organic food", "sweets", "beverages", "coffee", "tea", "spices", "sauces", "snacks"]
        }
        
        self.interests = {
            "fashion": ["fashion", "style", "trends", "shopping"],
            "beauty": ["beauty", "makeup", "self-care"],
            "tech": ["technology", "gaming", "programming", "gadgets"],
            "home": ["interior", "DIY", "gardening"],
            "books": ["reading", "literature", "education"],
            "sports": ["sports", "fitness", "yoga", "running"],
            "travel": ["travel", "culture", "photography"],
            "food": ["cooking", "healthy eating", "veganism"]
        }
        
        self.activity_levels = ["low", "medium", "high", "very high"]

    def _safe_sample(self, population: list, k: int) -> list:
        """Безпечний вибір елементів зі списку"""
        available = len(population)
        if available == 0:
            return []
        sample_size = min(k, available)
        return random.sample(population, k=sample_size)

    def generate_user(self, user_id: int, user_type: str = "random") -> Dict[str, Any]:
        """Генерує одного користувача"""
        
        if user_type == "random":
            user_type = random.choice(["fashion_lover", "tech_geek", "home_enthusiast", 
                                      "sports_fan", "book_worm", "beauty_guru"])
        
        age = self._generate_age_by_type(user_type)
        gender = random.choice(self.genders)
        city, region = random.choice(self.cities)
        
        # Генеруємо дані залежно від типу користувача
        if user_type == "fashion_lover":
            combined = self.product_categories["fashion"] + self.product_categories["beauty"]
            purchase_history = self._safe_sample(combined, random.randint(5, 10))
            cart = self._safe_sample(self.product_categories["fashion"], random.randint(0, 3))
            interests = self.interests["fashion"] + self._safe_sample(self.interests["beauty"], 2)
            
        elif user_type == "tech_geek":
            purchase_history = self._safe_sample(
                self.product_categories["tech"], 
                random.randint(5, 10)
            )
            cart = self._safe_sample(self.product_categories["tech"], random.randint(0, 3))
            interests = self.interests["tech"]
            
        elif user_type == "home_enthusiast":
            combined = self.product_categories["home"] + self.product_categories["food"]
            purchase_history = self._safe_sample(combined, random.randint(5, 10))
            cart = self._safe_sample(self.product_categories["home"], random.randint(0, 3))
            interests = self.interests["home"] + self._safe_sample(self.interests["food"], 2)
            
        elif user_type == "sports_fan":
            purchase_history = self._safe_sample(
                self.product_categories["sports"], 
                random.randint(5, 10)
            )
            cart = self._safe_sample(self.product_categories["sports"], random.randint(0, 3))
            interests = self.interests["sports"]
            
        elif user_type == "book_worm":
            purchase_history = self._safe_sample(
                self.product_categories["books"], 
                random.randint(5, 10)
            )
            cart = self._safe_sample(self.product_categories["books"], random.randint(0, 2))
            interests = self.interests["books"]
            
        else:  # beauty_guru
            combined = self.product_categories["beauty"] + self.product_categories["fashion"]
            purchase_history = self._safe_sample(combined, random.randint(5, 10))
            cart = self._safe_sample(self.product_categories["beauty"], random.randint(0, 4))
            interests = self.interests["beauty"] + self._safe_sample(self.interests["fashion"], 2)
        
        return {
            "user_id": user_id,
            "age": age,
            "gender": gender,
            "location": city,
            "region": region,
            "purchase_history": purchase_history,
            "cart": cart,
            "activity_level": random.choice(self.activity_levels),
            "religion": random.choice(self.religions),
            "interests": interests,
            "registration_date": self._random_date(),
            "last_purchase_date": self._random_date(days_back=30),
            "total_purchases": random.randint(1, 50),
            "average_order_value": round(random.uniform(300, 5000), 2)
        }
    
    def _generate_age_by_type(self, user_type: str) -> int:
        """Генерує вік залежно від типу користувача"""
        age_ranges = {
            "fashion_lover": (18, 35),
            "tech_geek": (20, 45),
            "home_enthusiast": (25, 55),
            "sports_fan": (18, 40),
            "book_worm": (22, 60),
            "beauty_guru": (18, 35)
        }
        min_age, max_age = age_ranges.get(user_type, (18, 65))
        return random.randint(min_age, max_age)
    
    def _random_date(self, days_back: int = 365) -> str:
        """Генерує випадкову дату"""
        days_ago = random.randint(0, days_back)
        date = datetime.now() - timedelta(days=days_ago)
        return date.strftime("%Y-%m-%d")
    
    def generate_dataset(self, num_users: int = 20, 
                        cluster_distribution: Dict[str, int] = None) -> List[Dict[str, Any]]:
        """Генерує датасет користувачів"""
        
        if cluster_distribution is None:
            cluster_distribution = {
                "fashion_lover": 5,
                "tech_geek": 4,
                "home_enthusiast": 3,
                "sports_fan": 3,
                "book_worm": 2,
                "beauty_guru": 3
            }
        
        users = []
        user_id = 1
        
        for user_type, count in cluster_distribution.items():
            for _ in range(count):
                users.append(self.generate_user(user_id, user_type))
                user_id += 1
        
        random.shuffle(users)
        return users


# ============== ТЕСТУВАННЯ ==============

def dashboard_update(data):
    """Симуляція дашборду"""
    print(f"\n{'='*60}")
    print(f"[GROK DASHBOARD] {datetime.now().strftime('%H:%M:%S')}")
    print(f"{'='*60}")
    print(json.dumps(data, ensure_ascii=False, indent=2))


def test_grok_agent():
    """Функція для тестування Grok агента"""
    
    print("GROK AGENT CLUSTERING TEST")
    print("="*70)
    
    # 1. Генеруємо фейкові дані
    print("\nStep 1: Generating test data...")
    generator = FakeDataGenerator()
    test_users = generator.generate_dataset(num_users=20)
    
    print(f"Generated {len(test_users)} users")
    print("\nSample users:")
    for user in test_users[:3]:
        print(f"\nUser {user['user_id']}:")
        print(f"  - Age: {user['age']}, Gender: {user['gender']}")
        print(f"  - Location: {user['location']}")
        print(f"  - Interests: {', '.join(user['interests'][:3])}")
        print(f"  - Purchase history: {', '.join(user['purchase_history'][:3])}")
    
    # 2. Ініціалізація Grok агента
    print("\n\nStep 2: Initializing Grok AI agent...")
    
    # ВАЖЛИВО: Вставте ваш xAI API ключ тут
    
    
    try:
        agent = GrokClusteringAgent(api_key="INSERT YOUR API KEY")
        print("Grok agent successfully initialized")
    except ValueError as e:
        print(f"Error: {e}")
        print("\nGet xAI API key at: https://console.x.ai/")
        print("Insert your key in 'xai_api_key' variable")
        return
    
    # 3. Запуск кластеризації
    print("\n\nStep 3: Running clustering with Grok...")
    print("Please wait, Grok is analyzing data...\n")
    
    result = agent.process_in_realtime(
        test_users, 
        dashboard_callback=dashboard_update
    )
    
    # 4. Аналіз результатів
    print("\n\nStep 4: Analyzing Grok results")
    print("="*70)
    
    if result["status"] == "success":
        data = result["data"]
        
        print(f"\nClustering completed successfully!")
        print(f"Model: {result['model']}")
        print(f"\nStatistics:")
        print(f"  - Tokens used: {result['tokens_used']['total']}")
        print(f"    • Prompt: {result['tokens_used']['prompt']}")
        print(f"    • Completion: {result['tokens_used']['completion']}")
        print(f"  - Clusters found: {len(data.get('clusters', []))}")
        print(f"  - Individual users: {len(data.get('individual_users', []))}")
        
        if data.get('clusters'):
            print(f"\n\nCluster details:")
            for cluster in data['clusters']:
                print(f"\nCluster #{cluster['cluster_id']}")
                print(f"  - Users: {len(cluster['user_ids'])} (IDs: {cluster['user_ids']})")
                print(f"  - Similarity: {cluster.get('similarity_score', 'N/A')}%")
                print(f"  - Common traits: {', '.join(cluster.get('common_traits', []))}")
                print(f"  - Recommended content: {cluster.get('recommended_content', 'N/A')}")
        
        if data.get('individual_users'):
            print(f"\n\nIndividual users:")
            for user in data['individual_users']:
                print(f"  - User {user['user_id']}: {user['reason']}")
        
        if data.get('processing_log'):
            print(f"\n\nProcessing log:")
            for log_entry in data['processing_log']:
                print(f"  • {log_entry}")
        
        output_file = "grok_clustering_result.json"
        with open(output_file, 'w', encoding='utf-8') as f:
            json.dump(result, f, ensure_ascii=False, indent=2)
        print(f"\n\nResult saved to file: {output_file}")
        
    else:
        print(f"\nClustering error:")
        print(f"  Error type: {result.get('error_type', 'Unknown')}")
        print(f"  Details: {result['error']}")
        if 'traceback' in result:
            print(f"\nFull traceback:")
            print(result['traceback'])
    
    print("\n\n" + "="*70)
    print("TEST COMPLETED")
    print("="*70)


if __name__ == "__main__":
    test_grok_agent()
